/-
Authors : James Gibson
-/

import tactic
import measure_theory.measurable_space
import probability.independence
import data.complex.exponential
import analysis.special_functions.exp

open topological_space measure_theory.measure probability_theory filter
open_locale classical measure_theory nnreal ennreal big_operators topological_space

namespace measure_theory 

/-Helpful lemma about a in the ennreals.-/
lemma help_lemma (a : â„â‰¥0âˆ) (h1 : a â‰¤ 1) (h2 :1 - a = 0): 
  a = 1 :=
begin
  rw tsub_eq_zero_iff_le at h2,
  exact ge_antisymm h2 h1,
end

/-One minus x is bounded from above by e^-x for all x.-/
lemma exp_bound_one_sub_x (x : â„) :
  1 - x â‰¤ real.exp (-x) :=
begin
  sorry,
end 

/-The Inter over j of the Inter up to j equals the total Inter for indexed sets.-/
lemma Inter_Inter_eq_Inter {Î± : Type*} (s : â„• â†’ set Î±) :
  (â‹‚ (j : â„•), â‹‚ (i : â„•) (h : i â‰¤ j), s i) = â‹‚ (i : â„•), s i :=
begin
  ext,
  split,
  { intros h s hs',
    cases hs' with a b,
    rw â† b,
    simp at h,
    exact h (a + 1) (a) (by norm_num),},
  { intros h s' hs',
    simp only [set.mem_range] at hs',
    simp at h,
    cases hs' with y,
    rw â† hs'_h,
    simp,
    intros i hi,
    exact h i,}
end

/-The sigma algebra generated by a set equals the sigma algebra generated by its complement.-/
lemma gen_singl_eq_compl_gen {Î± : Type*} {s : set Î±} :
  (@measurable_space.generate_from Î± {s}) = (measurable_space.generate_from {sá¶œ}) :=
begin
  sorry,
end

/-If 0 â‰¤ f â‰¤ g, then any finite product of the fs is less than the same finite prod of the gs-/
lemma pos_prod_lt_lt (f g : â„• â†’ â„) (hâ‚ : âˆ€ (n : â„•), 0 â‰¤ f n) (h : âˆ€ (n : â„•), f n â‰¤ g n) (a : â„•):
  âˆ (x : â„•) in finset.range a.succ, f x â‰¤ âˆ (x : â„•) in finset.range a.succ, g x :=
begin
  sorry,
end

/-If a sequence tends to -âˆ as it goes to âˆ, then the exp of the function tendsto 0 as it goes to âˆ.-/
lemma tendsto_exp_comp (s : â„• â†’ â„) : tendsto s at_top at_bot â†’
  tendsto (Î» (a : â„•), real.exp (s a)) at_top (ğ“ 0) :=
begin
  sorry,
end

/-Reverse of the Borel Cantelli lemma. For a sequence of measurable sets s, the sum of whose measure is 
    +âˆ, then the measure of the limsup of s is equal to one.-/
lemma Borel_cantelli_reverse  
  {Î± : Type*} (m : measurable_space Î±) (Î¼ : measure Î±) [hpm : is_probability_measure Î¼]
  {s : â„• â†’ set Î±} (hs : tendsto (Î» (a : â„•), âˆ‘ (x : â„•) in finset.range a, Î¼ (s x)) at_top at_top) 
  (hsI : Indep_set s Î¼) [add_comm_monoid â„•] [topological_space â„•] 
  [comm_monoid â„•] {hm : âˆ€ (i : â„•), measurable_set (s (i))}: 
  Î¼(limsup at_top s) = 1 :=
begin
  /-exchange lim sup to set operations.-/
  rw limsup_eq_infi_supr_of_nat',
  /-rw goal to the measure of the compliment of the limsup being 0-/
  suffices : 1 - Î¼(â¨… (n : â„•), â¨† (i : â„•), s (i + n)) = 0,
  {  exact help_lemma (Î¼(â¨… (n : â„•), â¨† (i : â„•), s (i + n))) prob_le_one this},
  rw â† hpm.measure_univ,
  have hlimsupm : measurable_set (â¨… (n : â„•), â¨† (i : â„•), s (i + n)) :=
    measurable_set.Inter (Î» b, measurable_set.Union $ Î» c, hm _),
      /-cred to Jason-/
  rw â† measure_compl hlimsupm,
  swap, sorry,
  /-move compliment inside the set operations.-/
  rw compl_infi,
  simp only [set.supr_eq_Union, set.compl_Union, measure_Union_null_iff],
  intros i,
  /-use independence of sets s n to prove independence of family s (n + i) for fixed i-/
  have hs_add_i_I: Indep_set (s âˆ˜ (Î» n, n + i))á¶œ Î¼,
  { unfold Indep_set,
    dsimp,
    simp_rw â† gen_singl_eq_compl_gen,
    intros s_1 f hyp,
    let adder : â„• â†ª â„• := âŸ¨(Î» n, n + i), sorryâŸ©,
    let s_2 : finset â„• := finset.map adder s_1,
    specialize @hsI s_2 (f âˆ˜ (Î» n, n-i)),
    dsimp at *,
    have : Î¼ (â‹‚ (i : â„•) (H : i âˆˆ s_1), f i) = s_1.prod (Î» (i : â„•), Î¼ (f i)) â†”
      Î¼ (â‹‚ (i_1 : â„•) (H : i_1 âˆˆ s_2), f (i_1 - i)) = s_2.prod (Î» (i_1 : â„•), Î¼ (f (i_1 - i))),
    { congr' 2,
      swap,
      /-True but want to move on for now.-/
      sorry,
      /-Also true but want to move on for now-/
      congr' 1,
      sorry},
    rw this,
    apply hsI,
    intros i_1 hi_1,
    have this2 : i_1 - i âˆˆ s_1, sorry,
    specialize hyp (i_1 - i) this2,
    let hyp' : i â‰¤ i_1 := sorry, 
    rw nat.sub_add_cancel hyp' at hyp,
    exact hyp,
    },
  /-change intersection into 2 intersections, Move the first intersection outside of the measure 
      into an infimum-/
  rw [â† Inter_Inter_eq_Inter, measure_Inter_eq_infi _ _ ],
  swap, sorry,
  swap, exact encodable.nat,
  swap, sorry,
  swap, sorry,
  /-Unfold Indep_set since there isnt much api for independence-/
  unfold Indep_set at *,
  /-convert intersection into intersection over finite set-/
  simp_rw [â† nat.lt_succ_iff, â† finset.mem_range],
  /-convert infimum equals zero into tendsto 0 proposition-/
  rw [â† ennreal.bot_eq_zero, infi_eq_bot],
  dsimp,
  /-change lt into a le in goal-/
  suffices : âˆ€ ( b : â„â‰¥0âˆ), b > 0 â†’  
    (âˆƒ (i_1 : â„•), Î¼ (â‹‚ (i_2 : â„•) (x : i_2 âˆˆ finset.range i_1.succ), (s (i_2 + i))á¶œ) â‰¤ b),
  { intros b hb,
    have hâ‚ : b â‰  0, intro h, finish,
    specialize this (b / 2) (ennreal.half_pos hâ‚),
    by_cases b â‰  âŠ¤,
    have hâ‚‚ : (b / 2) < b, exact ennreal.half_lt_self hâ‚ h,
    { cases this with i_1,
      use i_1,
      exact gt_of_gt_of_ge hâ‚‚ this_h},
    dsimp at h,
    rw not_not at h,
    use 1, rw h,
    exact gt_of_gt_of_ge (gt_iff_lt.mpr ennreal.one_lt_top) prob_le_one,
  },
  /-change into form which can be written into a tendsto form-/
  suffices : âˆ€ (b : â„â‰¥0âˆ), b > 0 â†’ 
    (âˆƒ (i_1 : â„•), âˆ€ (i_2 : â„•), i_2 â‰¥ i_1 â†’ Î¼ (â‹‚ (i_3 : â„•) (x : i_3 âˆˆ finset.range i_2.succ), (s (i_3 + i))á¶œ) â‰¤ b),
  { intros b hb,
    obtain âŸ¨N, hNâŸ© : âˆƒ (i_1 : â„•), âˆ€ (i_2 : â„•), i_2 â‰¥ i_1 â†’ 
      Î¼ (â‹‚ (i_3 : â„•) (x : i_3 âˆˆ finset.range i_2.succ), (s (i_3 + i))á¶œ) â‰¤ b :=
      this b hb,
    use N,
    exact hN N (by norm_num),
  },
  /-change into a tendsto proposition-/
  rw â† ennreal.tendsto_at_top_zero,
  unfold Indep at hs_add_i_I,
  unfold Indep_sets at hs_add_i_I,
  /-change measure of intersection to product of measures by continuity-/
  have big_help : (Î» (n : â„•), Î¼ (â‹‚ (i_3 : â„•) (x : i_3 âˆˆ finset.range n.succ), (s (i_3 + i))á¶œ)) = 
    (Î» (n : â„•), âˆ (i_3 : â„•) in finset.range n.succ, Î¼ (s (i_3 + i))á¶œ),
    ext1,
    specialize @hs_add_i_I (finset.range x.succ) (Î» n, (s (n + i))á¶œ),
    apply hs_add_i_I,
    intros j hj, dsimp,
    change (measurable_space.generate_from {(s (j + i))á¶œ}).measurable_set' (s (j + i))á¶œ,
    /-exact (measurable_space.generate_from {(s (j + i))á¶œ}).measurable_set' (s (j + i))á¶œ,-/
    sorry,
  rw big_help,  clear big_help, clear hs_add_i_I,
  /-left unfinished due to time constraints-/
  have this2 : âˆ€ (i_3 : â„•), Î¼ ((s (i_3 + i))á¶œ) = 1 - Î¼ (s (i_3 + i)), from sorry,
  simp_rw this2,
  /-convert to convergence in reals so we can apply exp function-/
  suffices : tendsto (Î» (n : â„•), ennreal.of_real (âˆ (x : â„•) in finset.range n.succ,  (1 - Î¼ (s (x + i))).to_real))
    at_top (ğ“ (ennreal.of_real 0)), sorry,
  apply ennreal.tendsto_of_real,
  /-move 1 outside of to_real-/
  simp_rw [ennreal.to_real_sub_of_le prob_le_one ennreal.one_ne_top, ennreal.one_to_real],
  /-replace goal with tendsto of sequence which bounds the function in the previous tendsto-/
  suffices : tendsto (Î» (a : â„•), âˆ (x : â„•) in finset.range a.succ, real.exp(-(Î¼ (s (x + i))).to_real)) at_top (ğ“ 0),
    sorry,
  /-exchange product of exps with exp of a sum-/
  simp_rw â† real.exp_sum,
  /-replace goal with showing sequence tends to -âˆ-/
  apply tendsto_exp_comp,
  /-replace goal with showing the negative of the sequence tends to +âˆ-/
  suffices : tendsto (Î» (a : â„•), âˆ‘ (x : â„•) in finset.range a, Î¼(s (x + i))) at_top at_top,
    sorry,
  suffices : tendsto (Î» (a : â„•), âˆ‘ (x : â„•) in finset.range a, Î¼(s x)) at_top at_top,
    sorry,
  simp,
  /-result should follow diectly from here but I have ran out of time-/
  assumption,
end 

end measure_theory