/-
Authors : James Gibson
-/

import tactic
import measure_theory.measurable_space
import probability.independence
import data.complex.exponential
import analysis.special_functions.exp

open topological_space measure_theory.measure probability_theory filter
open_locale classical measure_theory nnreal ennreal big_operators topological_space

namespace measure_theory 

/-Helpful lemma about a in the ennreals.-/
lemma help_lemma (a : ℝ≥0∞) (h1 : a ≤ 1) (h2 :1 - a = 0): 
  a = 1 :=
begin
  rw tsub_eq_zero_iff_le at h2,
  exact ge_antisymm h2 h1,
end

/-One minus x is bounded from above by e^-x for all x.-/
lemma exp_bound_one_sub_x (x : ℝ) :
  1 - x ≤ real.exp (-x) :=
begin
  sorry,
end 

/-The Inter over j of the Inter up to j equals the total Inter for indexed sets.-/
lemma Inter_Inter_eq_Inter {α : Type*} (s : ℕ → set α) :
  (⋂ (j : ℕ), ⋂ (i : ℕ) (h : i ≤ j), s i) = ⋂ (i : ℕ), s i :=
begin
  ext,
  split,
  { intros h s hs',
    cases hs' with a b,
    rw ← b,
    simp at h,
    exact h (a + 1) (a) (by norm_num),},
  { intros h s' hs',
    simp only [set.mem_range] at hs',
    simp at h,
    cases hs' with y,
    rw ← hs'_h,
    simp,
    intros i hi,
    exact h i,}
end

/-The sigma algebra generated by a set equals the sigma algebra generated by its complement.-/
lemma gen_singl_eq_compl_gen {α : Type*} {s : set α} :
  (@measurable_space.generate_from α {s}) = (measurable_space.generate_from {sᶜ}) :=
begin
  sorry,
end

/-If 0 ≤ f ≤ g, then any finite product of the fs is less than the same finite prod of the gs-/
lemma pos_prod_lt_lt (f g : ℕ → ℝ) (h₁ : ∀ (n : ℕ), 0 ≤ f n) (h : ∀ (n : ℕ), f n ≤ g n) (a : ℕ):
  ∏ (x : ℕ) in finset.range a.succ, f x ≤ ∏ (x : ℕ) in finset.range a.succ, g x :=
begin
  sorry,
end

/-If a sequence tends to -∞ as it goes to ∞, then the exp of the function tendsto 0 as it goes to ∞.-/
lemma tendsto_exp_comp (s : ℕ → ℝ) : tendsto s at_top at_bot →
  tendsto (λ (a : ℕ), real.exp (s a)) at_top (𝓝 0) :=
begin
  sorry,
end

/-Reverse of the Borel Cantelli lemma. For a sequence of measurable sets s, the sum of whose measure is 
    +∞, then the measure of the limsup of s is equal to one.-/
lemma Borel_cantelli_reverse  
  {α : Type*} (m : measurable_space α) (μ : measure α) [hpm : is_probability_measure μ]
  {s : ℕ → set α} (hs : tendsto (λ (a : ℕ), ∑ (x : ℕ) in finset.range a, μ (s x)) at_top at_top) 
  (hsI : Indep_set s μ) [add_comm_monoid ℕ] [topological_space ℕ] 
  [comm_monoid ℕ] {hm : ∀ (i : ℕ), measurable_set (s (i))}: 
  μ(limsup at_top s) = 1 :=
begin
  /-exchange lim sup to set operations.-/
  rw limsup_eq_infi_supr_of_nat',
  /-rw goal to the measure of the compliment of the limsup being 0-/
  suffices : 1 - μ(⨅ (n : ℕ), ⨆ (i : ℕ), s (i + n)) = 0,
  {  exact help_lemma (μ(⨅ (n : ℕ), ⨆ (i : ℕ), s (i + n))) prob_le_one this},
  rw ← hpm.measure_univ,
  have hlimsupm : measurable_set (⨅ (n : ℕ), ⨆ (i : ℕ), s (i + n)) :=
    measurable_set.Inter (λ b, measurable_set.Union $ λ c, hm _),
      /-cred to Jason-/
  rw ← measure_compl hlimsupm,
  swap, sorry,
  /-move compliment inside the set operations.-/
  rw compl_infi,
  simp only [set.supr_eq_Union, set.compl_Union, measure_Union_null_iff],
  intros i,
  /-use independence of sets s n to prove independence of family s (n + i) for fixed i-/
  have hs_add_i_I: Indep_set (s ∘ (λ n, n + i))ᶜ μ,
  { unfold Indep_set,
    dsimp,
    simp_rw ← gen_singl_eq_compl_gen,
    intros s_1 f hyp,
    let adder : ℕ ↪ ℕ := ⟨(λ n, n + i), sorry⟩,
    let s_2 : finset ℕ := finset.map adder s_1,
    specialize @hsI s_2 (f ∘ (λ n, n-i)),
    dsimp at *,
    have : μ (⋂ (i : ℕ) (H : i ∈ s_1), f i) = s_1.prod (λ (i : ℕ), μ (f i)) ↔
      μ (⋂ (i_1 : ℕ) (H : i_1 ∈ s_2), f (i_1 - i)) = s_2.prod (λ (i_1 : ℕ), μ (f (i_1 - i))),
    { congr' 2,
      swap,
      /-True but want to move on for now.-/
      sorry,
      /-Also true but want to move on for now-/
      congr' 1,
      sorry},
    rw this,
    apply hsI,
    intros i_1 hi_1,
    have this2 : i_1 - i ∈ s_1, sorry,
    specialize hyp (i_1 - i) this2,
    let hyp' : i ≤ i_1 := sorry, 
    rw nat.sub_add_cancel hyp' at hyp,
    exact hyp,
    },
  /-change intersection into 2 intersections, Move the first intersection outside of the measure 
      into an infimum-/
  rw [← Inter_Inter_eq_Inter, measure_Inter_eq_infi _ _ ],
  swap, sorry,
  swap, exact encodable.nat,
  swap, sorry,
  swap, sorry,
  /-Unfold Indep_set since there isnt much api for independence-/
  unfold Indep_set at *,
  /-convert intersection into intersection over finite set-/
  simp_rw [← nat.lt_succ_iff, ← finset.mem_range],
  /-convert infimum equals zero into tendsto 0 proposition-/
  rw [← ennreal.bot_eq_zero, infi_eq_bot],
  dsimp,
  /-change lt into a le in goal-/
  suffices : ∀ ( b : ℝ≥0∞), b > 0 →  
    (∃ (i_1 : ℕ), μ (⋂ (i_2 : ℕ) (x : i_2 ∈ finset.range i_1.succ), (s (i_2 + i))ᶜ) ≤ b),
  { intros b hb,
    have h₁ : b ≠ 0, intro h, finish,
    specialize this (b / 2) (ennreal.half_pos h₁),
    by_cases b ≠ ⊤,
    have h₂ : (b / 2) < b, exact ennreal.half_lt_self h₁ h,
    { cases this with i_1,
      use i_1,
      exact gt_of_gt_of_ge h₂ this_h},
    dsimp at h,
    rw not_not at h,
    use 1, rw h,
    exact gt_of_gt_of_ge (gt_iff_lt.mpr ennreal.one_lt_top) prob_le_one,
  },
  /-change into form which can be written into a tendsto form-/
  suffices : ∀ (b : ℝ≥0∞), b > 0 → 
    (∃ (i_1 : ℕ), ∀ (i_2 : ℕ), i_2 ≥ i_1 → μ (⋂ (i_3 : ℕ) (x : i_3 ∈ finset.range i_2.succ), (s (i_3 + i))ᶜ) ≤ b),
  { intros b hb,
    obtain ⟨N, hN⟩ : ∃ (i_1 : ℕ), ∀ (i_2 : ℕ), i_2 ≥ i_1 → 
      μ (⋂ (i_3 : ℕ) (x : i_3 ∈ finset.range i_2.succ), (s (i_3 + i))ᶜ) ≤ b :=
      this b hb,
    use N,
    exact hN N (by norm_num),
  },
  /-change into a tendsto proposition-/
  rw ← ennreal.tendsto_at_top_zero,
  unfold Indep at hs_add_i_I,
  unfold Indep_sets at hs_add_i_I,
  /-change measure of intersection to product of measures by continuity-/
  have big_help : (λ (n : ℕ), μ (⋂ (i_3 : ℕ) (x : i_3 ∈ finset.range n.succ), (s (i_3 + i))ᶜ)) = 
    (λ (n : ℕ), ∏ (i_3 : ℕ) in finset.range n.succ, μ (s (i_3 + i))ᶜ),
    ext1,
    specialize @hs_add_i_I (finset.range x.succ) (λ n, (s (n + i))ᶜ),
    apply hs_add_i_I,
    intros j hj, dsimp,
    change (measurable_space.generate_from {(s (j + i))ᶜ}).measurable_set' (s (j + i))ᶜ,
    /-exact (measurable_space.generate_from {(s (j + i))ᶜ}).measurable_set' (s (j + i))ᶜ,-/
    sorry,
  rw big_help,  clear big_help, clear hs_add_i_I,
  /-left unfinished due to time constraints-/
  have this2 : ∀ (i_3 : ℕ), μ ((s (i_3 + i))ᶜ) = 1 - μ (s (i_3 + i)), from sorry,
  simp_rw this2,
  /-convert to convergence in reals so we can apply exp function-/
  suffices : tendsto (λ (n : ℕ), ennreal.of_real (∏ (x : ℕ) in finset.range n.succ,  (1 - μ (s (x + i))).to_real))
    at_top (𝓝 (ennreal.of_real 0)), sorry,
  apply ennreal.tendsto_of_real,
  /-move 1 outside of to_real-/
  simp_rw [ennreal.to_real_sub_of_le prob_le_one ennreal.one_ne_top, ennreal.one_to_real],
  /-replace goal with tendsto of sequence which bounds the function in the previous tendsto-/
  suffices : tendsto (λ (a : ℕ), ∏ (x : ℕ) in finset.range a.succ, real.exp(-(μ (s (x + i))).to_real)) at_top (𝓝 0),
    sorry,
  /-exchange product of exps with exp of a sum-/
  simp_rw ← real.exp_sum,
  /-replace goal with showing sequence tends to -∞-/
  apply tendsto_exp_comp,
  /-replace goal with showing the negative of the sequence tends to +∞-/
  suffices : tendsto (λ (a : ℕ), ∑ (x : ℕ) in finset.range a, μ(s (x + i))) at_top at_top,
    sorry,
  suffices : tendsto (λ (a : ℕ), ∑ (x : ℕ) in finset.range a, μ(s x)) at_top at_top,
    sorry,
  simp,
  /-result should follow diectly from here but I have ran out of time-/
  assumption,
end 

end measure_theory